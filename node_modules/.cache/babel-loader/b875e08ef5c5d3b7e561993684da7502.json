{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport { map, scan, filter, observeOn } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from '@firebase/app';\nimport { registerFirestore } from '@firebase/firestore';\nimport 'firebase/firestore';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T, R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  subscriber => {\n    /** @type {?} */\n    let unsubscribe;\n\n    if (scheduler != null) {\n      scheduler.schedule(\n      /**\n      * @return {?}\n      */\n      () => {\n        unsubscribe = ref.onSnapshot(subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot(subscriber);\n    }\n\n    return (\n      /**\n      * @return {?}\n      */\n      function () {\n        if (unsubscribe != null) {\n          unsubscribe();\n        }\n      }\n    );\n  });\n}\n/**\n * @template R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n  payload => ({\n    payload,\n    type: 'value'\n  })));\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n  payload => ({\n    payload,\n    type: 'query'\n  })));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(\n  /**\n  * @param {?} action\n  * @return {?}\n  */\n  action => action.payload.docChanges().map(\n  /**\n  * @param {?} change\n  * @return {?}\n  */\n  change => (\n  /** @type {?} */\n  {\n    type: change.type,\n    payload: change\n  }))));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @template T\n * @param {?} query\n * @param {?} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction sortedChanges(query, events, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n  changes => changes.payload.docChanges()), scan(\n  /**\n  * @param {?} current\n  * @param {?} changes\n  * @return {?}\n  */\n  (current, changes) => combineChanges(current, changes, events), []), map(\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n  changes => changes.map(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  c => (\n  /** @type {?} */\n  {\n    type: c.type,\n    payload: c\n  }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @template T\n * @param {?} current\n * @param {?} changes\n * @param {?} events\n * @return {?}\n */\n\n\nfunction combineChanges(current, changes, events) {\n  changes.forEach(\n  /**\n  * @param {?} change\n  * @return {?}\n  */\n  change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Creates a new sorted array from a new change.\n * @template T\n * @param {?} combined\n * @param {?} change\n * @return {?}\n */\n\n\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired\n      } else {\n        combined.splice(change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?=} events\n * @return {?}\n */\n\n\nfunction validateEventsArray(events) {\n  if (!events ||\n  /** @type {?} */\n  events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nclass AngularFirestoreCollection {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param {?} ref\n   * @param {?} query\n   * @param {?} afs\n   */\n  constructor(ref, query, afs) {\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n    }\n\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n    /**\n    * @param {?} actions\n    * @return {?}\n    */\n    actions => actions.filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => events.indexOf(change.type) > -1)), filter(\n    /**\n    * @param {?} changes\n    * @return {?}\n    */\n    changes => changes.length > 0), this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan(\n    /**\n    * @param {?} current\n    * @param {?} action\n    * @return {?}\n    */\n    (current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  snapshotChanges(events) {\n    /** @type {?} */\n    const validatedEvents = validateEventsArray(events);\n    /** @type {?} */\n\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * @template K\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  valueChanges(options = {}) {\n    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n    /**\n    * @param {?} actions\n    * @return {?}\n    */\n    actions => actions.payload.docs.map(\n    /**\n    * @param {?} a\n    * @return {?}\n    */\n    a => {\n      if (options.idField) {\n        return (\n          /** @type {?} */\n          Object.assign(Object.assign({},\n          /** @type {?} */\n          a.data()), {\n            [options.idField]: a.id\n          })\n        );\n      } else {\n        return a.data();\n      }\n    })), this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n  }\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   * @param {?} data\n   * @return {?}\n   */\n\n\n  add(data) {\n    return this.ref.add(data);\n  }\n  /**\n   * Create a reference to a single document in a collection.\n   * @template T\n   * @param {?=} path\n   * @return {?}\n   */\n\n\n  doc(path) {\n    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreCollection.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n * @template T\n */\n\n\nclass AngularFirestoreDocument {\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param {?} ref\n   * @param {?} afs\n   */\n  constructor(ref, afs) {\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   * @param {?} data\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  set(data, options) {\n    return this.ref.set(data, options);\n  }\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param {?} data\n   * @return {?}\n   */\n\n\n  update(data) {\n    return this.ref.update(data);\n  }\n  /**\n   * Delete a document.\n   * @return {?}\n   */\n\n\n  delete() {\n    return this.ref.delete();\n  }\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @template R\n   * @param {?} path\n   * @param {?=} queryFn\n   * @return {?}\n   */\n\n\n  collection(path, queryFn) {\n    /** @type {?} */\n    const collectionRef = this.ref.collection(path);\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n  /**\n   * Listen to snapshot updates from the document.\n   * @return {?}\n   */\n\n\n  snapshotChanges() {\n    /** @type {?} */\n    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   * @return {?}\n   */\n\n\n  valueChanges() {\n    return this.snapshotChanges().pipe(map(\n    /**\n    * @param {?} action\n    * @return {?}\n    */\n    action => {\n      return action.payload.data();\n    }));\n  }\n  /**\n   * Retrieve the document once.\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  get(options) {\n    return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreDocument.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreDocument.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nclass AngularFirestoreCollectionGroup {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   * @param {?} query\n   * @param {?} afs\n   */\n  constructor(query, afs) {\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n    }\n\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n    /**\n    * @param {?} actions\n    * @return {?}\n    */\n    actions => actions.filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => events.indexOf(change.type) > -1)), filter(\n    /**\n    * @param {?} changes\n    * @return {?}\n    */\n    changes => changes.length > 0), this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan(\n    /**\n    * @param {?} current\n    * @param {?} action\n    * @return {?}\n    */\n    (current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  snapshotChanges(events) {\n    /** @type {?} */\n    const validatedEvents = validateEventsArray(events);\n    /** @type {?} */\n\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   * @return {?}\n   */\n\n\n  valueChanges() {\n    /** @type {?} */\n    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$.pipe(map(\n    /**\n    * @param {?} actions\n    * @return {?}\n    */\n    actions => actions.payload.docs.map(\n    /**\n    * @param {?} a\n    * @return {?}\n    */\n    a => a.data())), this.afs.keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  AngularFirestoreCollectionGroup.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollectionGroup.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n * @type {?}\n */\n\n\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\n/** @type {?} */\n\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\n/** @type {?} */\n\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param {?} collectionRef - A collection reference to query\n * @param {?=} queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n * @return {?}\n */\n\nfunction associateQuery(collectionRef, queryFn =\n/**\n* @param {?} ref\n* @return {?}\n*/\nref => ref) {\n  /** @type {?} */\n  const query = queryFn(collectionRef);\n  /** @type {?} */\n\n  const ref = collectionRef;\n  return {\n    query,\n    ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '\\@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '\\@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * \\@Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n\n\nclass AngularFirestore {\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   * @param {?} options\n   * @param {?} nameOrConfig\n   * @param {?} shouldEnablePersistence\n   * @param {?} settings\n   * @param {?} platformId\n   * @param {?} zone\n   * @param {?} persistenceSettings\n   */\n  constructor(options, nameOrConfig, shouldEnablePersistence, settings, platformId, zone, persistenceSettings) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n    this.firestore = zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => {\n      /** @type {?} */\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig); // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?\n      //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register\n      //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue\n\n      if (registerFirestore) {\n        registerFirestore(firebase);\n      }\n      /** @type {?} */\n\n\n      const firestore = app.firestore();\n\n      if (settings) {\n        firestore.settings(settings);\n      }\n\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      // We need to try/catch here because not all enablePersistence() failures are caught\n      // https://github.com/firebase/firebase-js-sdk/issues/608\n\n      /** @type {?} */\n      const enablePersistence =\n      /**\n      * @return {?}\n      */\n      () => {\n        try {\n          return from(this.firestore.enablePersistence(persistenceSettings || undefined).then(\n          /**\n          * @return {?}\n          */\n          () => true,\n          /**\n          * @return {?}\n          */\n          () => false));\n        } catch (e) {\n          return of(false);\n        }\n      };\n\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n  /**\n   * @template T\n   * @param {?} pathOrRef\n   * @param {?=} queryFn\n   * @return {?}\n   */\n\n\n  collection(pathOrRef, queryFn) {\n    /** @type {?} */\n    let collectionRef;\n\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this);\n  }\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   * @template T\n   * @param {?} collectionId\n   * @param {?=} queryGroupFn\n   * @return {?}\n   */\n\n\n  collectionGroup(collectionId, queryGroupFn) {\n    /** @type {?} */\n    const queryFn = queryGroupFn || (\n    /**\n    * @param {?} ref\n    * @return {?}\n    */\n    ref => ref);\n    /** @type {?} */\n\n\n    const collectionGroup = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n  }\n  /**\n   * @template T\n   * @param {?} pathOrRef\n   * @return {?}\n   */\n\n\n  doc(pathOrRef) {\n    /** @type {?} */\n    let ref;\n\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n\n    return new AngularFirestoreDocument(ref, this);\n  }\n  /**\n   * Returns a generated Firestore Document Id.\n   * @return {?}\n   */\n\n\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n\n}\n\nAngularFirestore.ɵfac = function AngularFirestore_Factory(t) {\n  return new (t || AngularFirestore)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(ENABLE_PERSISTENCE, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PERSISTENCE_SETTINGS, 8));\n};\n/** @nocollapse */\n\n\nAngularFirestore.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [FIREBASE_OPTIONS]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [FIREBASE_APP_NAME]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [ENABLE_PERSISTENCE]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [SETTINGS]\n  }]\n}, {\n  type: Object,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}, {\n  type: NgZone\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [PERSISTENCE_SETTINGS]\n  }]\n}];\n/** @nocollapse */\n\n\nAngularFirestore.ɵprov = ɵɵdefineInjectable({\n  factory: function AngularFirestore_Factory() {\n    return new AngularFirestore(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(ENABLE_PERSISTENCE, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(PERSISTENCE_SETTINGS, 8));\n  },\n  token: AngularFirestore,\n  providedIn: \"any\"\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFirestore, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ENABLE_PERSISTENCE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SETTINGS]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PERSISTENCE_SETTINGS]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestore.prototype.firestore;\n  /** @type {?} */\n\n  AngularFirestore.prototype.persistenceEnabled$;\n  /** @type {?} */\n\n  AngularFirestore.prototype.schedulers;\n  /** @type {?} */\n\n  AngularFirestore.prototype.keepUnstableUntilFirst;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   * @param {?=} persistenceSettings\n   * @return {?}\n   */\n  static enablePersistence(persistenceSettings) {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [{\n        provide: ENABLE_PERSISTENCE,\n        useValue: true\n      }, {\n        provide: PERSISTENCE_SETTINGS,\n        useValue: persistenceSettings\n      }]\n    };\n  }\n\n}\n\nAngularFirestoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AngularFirestoreModule\n});\nAngularFirestoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function AngularFirestoreModule_Factory(t) {\n    return new (t || AngularFirestoreModule)();\n  },\n  providers: [AngularFirestore]\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFirestoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [AngularFirestore]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentSnapshotExists() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotExists.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotExists.prototype.data = function (options) {};\n}\n/**\n * @record\n */\n\n\nfunction DocumentSnapshotDoesNotExist() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotDoesNotExist.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotDoesNotExist.prototype.data = function (options) {};\n  /**\n   * @param {?} fieldPath\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  DocumentSnapshotDoesNotExist.prototype.get = function (fieldPath, options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QueryDocumentSnapshot() {}\n\nif (false) {\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n  QueryDocumentSnapshot.prototype.data = function (options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QuerySnapshot() {}\n\nif (false) {\n  /** @type {?} */\n  QuerySnapshot.prototype.docs;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChange() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChange.prototype.doc;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChangeAction() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChangeAction.prototype.type;\n  /** @type {?} */\n\n  DocumentChangeAction.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction Action() {}\n\nif (false) {\n  /** @type {?} */\n  Action.prototype.type;\n  /** @type {?} */\n\n  Action.prototype.payload;\n}\n\n;\n/**\n * @record\n * @template T\n */\n\nfunction Reference() {}\n\nif (false) {\n  /** @type {?} */\n  Reference.prototype.onSnapshot;\n}\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n * @record\n */\n\n\nfunction AssociatedReference() {}\n\nif (false) {\n  /** @type {?} */\n  AssociatedReference.prototype.ref;\n  /** @type {?} */\n\n  AssociatedReference.prototype.query;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };","map":{"version":3,"sources":["ng:/@angular/fire/firestore/observable/fromRef.ts","ng:/@angular/fire/firestore/collection/changes.ts","ng:/@angular/fire/firestore/collection/collection.ts","ng:/@angular/fire/firestore/document/document.ts","ng:/@angular/fire/firestore/collection-group/collection-group.ts","ng:/@angular/fire/firestore/firestore.ts","ng:/@angular/fire/firestore/firestore.module.ts","ng:/@angular/fire/firestore/interfaces.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, SchedulerLike, asyncScheduler } from 'rxjs';\nimport { DocumentReference, Query, Action, Reference, DocumentSnapshot, QuerySnapshot } from '../interfaces';\nimport { map } from 'rxjs/operators';\n\nfunction _fromRef<T, R>(ref: Reference<T>, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot(subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot(subscriber);\n    }\n\n    return function() {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    }\n  });\n}\n\nexport function fromRef<R>(ref: DocumentReference | Query, scheduler?: SchedulerLike) {\n  return _fromRef<typeof ref, R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>>{\n  return fromRef<DocumentSnapshot<T>>(ref, scheduler)\n    .pipe(\n      map(payload => ({ payload, type: 'value' }))\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { map, scan } from 'rxjs/operators';\n\nimport { Query, DocumentChangeType, DocumentChange, DocumentChangeAction } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(action =>\n        action.payload.docChanges()\n          .map(change => ({ type: change.type, payload: change } as DocumentChangeAction<T>))));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges<T>(query: Query, events: DocumentChangeType[], scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(changes => changes.payload.docChanges()),\n      scan((current, changes) => combineChanges(current, changes, events), []),\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if(events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch(change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        combined.splice(change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if(change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, CollectionReference, Query, DocumentReference, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if(!events || events!.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param ref\n   */\n  constructor(\n    public readonly ref: CollectionReference,\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n      map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n      filter(changes =>  changes.length > 0),\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   * @param options\n   */\n  valueChanges(): Observable<T[]>\n  valueChanges({}): Observable<T[]>\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as Object,\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data()\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   * @param path\n   */\n  doc<T>(path?: string): AngularFirestoreDocument<T> {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\n  }\n}\n","import { Observable, from } from 'rxjs';\nimport { DocumentReference, SetOptions, DocumentData, QueryFn, Action, DocumentSnapshot } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { firestore } from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T=DocumentData> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param ref\n   */\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   * @param data\n   * @param options\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param data\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @param path\n   * @param queryFn\n   */\n  collection<R=DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<R>(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    )\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T|undefined> {\n    return this.snapshotChanges().pipe(\n      map(action => {\n        return action.payload.data();\n      })\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n","import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, Query, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { validateEventsArray } from '../collection/collection';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { AngularFirestore } from '../firestore';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   * @param query\n   * @param afs\n   */\n  constructor(\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   */\n  valueChanges(): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => a.data())),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular)\n    );\n  }\n\n}\n","import { InjectionToken, NgZone, PLATFORM_ID, Injectable, Inject, Optional } from '@angular/core';\nimport { Observable, of, from } from 'rxjs';\nimport { Settings, PersistenceSettings, CollectionReference, DocumentReference, QueryFn, Query, QueryGroupFn, AssociatedReference } from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport { FirebaseOptions, FirebaseAppConfig, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵfirebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport { firestore } from 'firebase/app';\nimport firebase from '@firebase/app';\nimport { registerFirestore } from '@firebase/firestore';\nimport 'firebase/firestore';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings|undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery(collectionRef: CollectionReference, queryFn = ref => ref): AssociatedReference {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   * @param app\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options:FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig:string|FirebaseAppConfig|null|undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean|null,\n    @Optional() @Inject(SETTINGS) settings: Settings|null,\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings|null,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n\n    this.firestore = zone.runOutsideAngular(() => {\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?\n      //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register\n      //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue\n      if (registerFirestore) { registerFirestore(firebase) }\n      const firestore = app.firestore();\n      if (settings) { firestore.settings(settings) }\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      // We need to try/catch here because not all enablePersistence() failures are caught\n      // https://github.com/firebase/firebase-js-sdk/issues/608\n      const enablePersistence = () => {\n        try {\n          return from(this.firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n        } catch(e) {\n          return of(false);\n        }\n      };\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   * @param pathOrRef\n   * @param queryFn\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(pathOrRef: string | CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<T>(ref, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   * @param collectionId\n   * @param queryGroupFn\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   * @param pathOrRef\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>\n  doc<T>(pathOrRef: string | DocumentReference): AngularFirestoreDocument<T> {\n    let ref: DocumentReference;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    return new AngularFirestoreDocument<T>(ref, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { PersistenceSettings } from './interfaces';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    }\n  }\n}\n","import { Subscriber } from 'rxjs';\nimport { firestore } from 'firebase/app';\n\nexport type Settings =  firestore.Settings;\nexport type CollectionReference = firestore.CollectionReference;\nexport type DocumentReference = firestore.DocumentReference;\nexport type PersistenceSettings = firestore.PersistenceSettings;\nexport type DocumentChangeType = firestore.DocumentChangeType;\nexport type SnapshotOptions = firestore.SnapshotOptions;\nexport type FieldPath = firestore.FieldPath;\nexport type Query = firestore.Query;\n\nexport type SetOptions = firestore.SetOptions;\nexport type DocumentData = firestore.DocumentData;\n\nexport interface DocumentSnapshotExists<T> extends firestore.DocumentSnapshot {\n  readonly exists: true;\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface DocumentSnapshotDoesNotExist extends firestore.DocumentSnapshot {\n  readonly exists: false;\n  data(options?: SnapshotOptions): undefined;\n  get(fieldPath: string | FieldPath, options?: SnapshotOptions): undefined;\n}\n\nexport type DocumentSnapshot<T> = DocumentSnapshotExists<T> | DocumentSnapshotDoesNotExist;\n\nexport interface QueryDocumentSnapshot<T> extends firestore.QueryDocumentSnapshot {\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface QuerySnapshot<T> extends firestore.QuerySnapshot {\n  readonly docs: QueryDocumentSnapshot<T>[];\n}\n\nexport interface DocumentChange<T> extends firestore.DocumentChange {\n  readonly doc: QueryDocumentSnapshot<T>;\n}\n\nexport interface DocumentChangeAction<T> {\n  type: DocumentChangeType;\n  payload: DocumentChange<T>;\n}\n\nexport interface Action<T> {\n  type: string;\n  payload: T;\n};\n\nexport interface Reference<T> {\n  onSnapshot: (sub: Subscriber<any>) => any;\n}\n\n// A convience type for making a query.\n// Example: const query = (ref) => ref.where('name', == 'david');\nexport type QueryFn = (ref: CollectionReference) => Query;\n\nexport type QueryGroupFn = (query: Query) => Query;\n\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n */\nexport interface AssociatedReference {\n  ref: CollectionReference;\n  query: Query;\n}\n"]},"metadata":{},"sourceType":"module"}