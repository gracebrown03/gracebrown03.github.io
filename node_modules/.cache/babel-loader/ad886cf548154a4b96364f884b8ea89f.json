{"ast":null,"code":"import { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport { apps, initializeApp, registerVersion } from 'firebase/app';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n\n\nclass ɵZoneScheduler {\n  /**\n   * @param {?} zone\n   * @param {?=} delegate\n   */\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  now() {\n    return this.delegate.now();\n  }\n  /**\n   * @param {?} work\n   * @param {?=} delay\n   * @param {?=} state\n   * @return {?}\n   */\n\n\n  schedule(work, delay, state) {\n    /** @type {?} */\n    const targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n\n    /** @type {?} */\n\n    const workInZone =\n    /**\n    * @this {?}\n    * @param {?} state\n    * @return {?}\n    */\n    function (state) {\n      targetZone.runGuarded(\n      /**\n      * @return {?}\n      */\n      () => {\n        work.apply(this, [state]);\n      });\n    } // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    ; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵZoneScheduler.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵZoneScheduler.prototype.delegate;\n}\n/**\n * @template T\n */\n\n\nclass ɵBlockUntilFirstOperator {\n  /**\n   * @param {?} zone\n   */\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n  /**\n   * @param {?} subscriber\n   * @param {?} source\n   * @return {?}\n   */\n\n\n  call(subscriber, source) {\n    /** @type {?} */\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(\n    /**\n    * @return {?}\n    */\n    () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on    \n    setTimeout(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵBlockUntilFirstOperator.prototype.task;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵBlockUntilFirstOperator.prototype.zone;\n}\n\nclass ɵAngularFireSchedulers {\n  /**\n   * @param {?} ngZone\n   */\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.outsideAngular = ngZone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(\n    /**\n    * @return {?}\n    */\n    () => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ɵAngularFireSchedulers.prototype.outsideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.insideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.ngZone;\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n * @param {?} schedulers\n * @param {?} platformId\n * @return {?}\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\n  return (\n    /**\n    * @template T\n    * @param {?} obs$\n    * @return {?}\n    */\n    function keepUnstableUntilFirst(obs$) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n      return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n      // share()\n      );\n    }\n  );\n} // DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n\n/** @type {?} */\n\n\nconst noopFunctions = ['ngOnDestroy']; // INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n\n/** @type {?} */\n\nconst ɵlazySDKProxy =\n/**\n* @param {?} klass\n* @param {?} observable\n* @param {?} zone\n* @return {?}\n*/\n(klass, observable, zone) => {\n  return new Proxy(klass, {\n    get:\n    /**\n    * @param {?} _\n    * @param {?} name\n    * @return {?}\n    */\n    (_, name) => zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (klass[name]) {\n        return klass[name];\n      }\n\n      if (noopFunctions.includes(name)) {\n        return (\n          /**\n          * @return {?}\n          */\n          () => {}\n        );\n      }\n      /** @type {?} */\n\n\n      let promise = observable.toPromise().then(\n      /**\n      * @param {?} mod\n      * @return {?}\n      */\n      mod => {\n        /** @type {?} */\n        const ret = mod && mod[name]; // TODO move to proper type guards\n\n        if (typeof ret == 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then(\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          res => zone.run(\n          /**\n          * @return {?}\n          */\n          () => res));\n        } else {\n          return zone.run(\n          /**\n          * @return {?}\n          */\n          () => ret);\n        }\n      }); // recurse the proxy\n\n      return new Proxy(\n      /**\n      * @return {?}\n      */\n      () => undefined, {\n        get:\n        /**\n        * @param {?} _\n        * @param {?} name\n        * @return {?}\n        */\n        (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can \n        apply:\n        /**\n        * @param {?} self\n        * @param {?} _\n        * @param {?} args\n        * @return {?}\n        */\n        (self, _, args) => promise.then(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        it => it && it(...args))\n      });\n    })\n  });\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction FirebaseOptions() {}\n\n;\n/**\n * @record\n */\n\nfunction FirebaseAppConfig() {}\n\n;\n/** @type {?} */\n\nconst FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\n/** @type {?} */\n\nconst FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig'); // Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\n\nclass FirebaseApp {}\n\nif (false) {\n  /** @type {?} */\n  FirebaseApp.prototype.name;\n  /** @type {?} */\n\n  FirebaseApp.prototype.options;\n  /** @type {?} */\n\n  FirebaseApp.prototype.analytics;\n  /** @type {?} */\n\n  FirebaseApp.prototype.auth;\n  /** @type {?} */\n\n  FirebaseApp.prototype.database;\n  /** @type {?} */\n\n  FirebaseApp.prototype.messaging;\n  /** @type {?} */\n\n  FirebaseApp.prototype.performance;\n  /** @type {?} */\n\n  FirebaseApp.prototype.storage;\n  /** @type {?} */\n\n  FirebaseApp.prototype.delete;\n  /** @type {?} */\n\n  FirebaseApp.prototype.firestore;\n  /** @type {?} */\n\n  FirebaseApp.prototype.functions;\n  /** @type {?} */\n\n  FirebaseApp.prototype.remoteConfig;\n}\n/** @type {?} */\n\n\nconst VERSION = new Version('6.0.0');\n/**\n * @param {?} options\n * @param {?} zone\n * @param {?=} nameOrConfig\n * @return {?}\n */\n\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  /** @type {?} */\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  /** @type {?} */\n\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name; // Added any due to some inconsistency between @firebase/app and firebase types\n\n  /** @type {?} */\n\n  const existingApp =\n  /** @type {?} */\n  apps.filter(\n  /**\n  * @param {?} app\n  * @return {?}\n  */\n  app => app && app.name === config.name)[0]; // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n\n  return (\n    /** @type {?} */\n    existingApp || zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => initializeApp(options,\n    /** @type {?} */\n    config))\n  );\n}\n/** @type {?} */\n\n\nconst FirebaseAppProvider = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [new Optional(), FIREBASE_APP_NAME]]\n};\n\nclass AngularFireModule {\n  /**\n   * @param {?} platformId\n   */\n  constructor(platformId) {\n    registerVersion('angularfire', VERSION.full, platformId.toString());\n    registerVersion('angular', VERSION$1.full);\n  }\n  /**\n   * @param {?} options\n   * @param {?=} nameOrConfig\n   * @return {?}\n   */\n\n\n  static initializeApp(options, nameOrConfig) {\n    return {\n      ngModule: AngularFireModule,\n      providers: [{\n        provide: FIREBASE_OPTIONS,\n        useValue: options\n      }, {\n        provide: FIREBASE_APP_NAME,\n        useValue: nameOrConfig\n      }]\n    };\n  }\n\n}\n\nAngularFireModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AngularFireModule\n});\nAngularFireModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function AngularFireModule_Factory(t) {\n    return new (t || AngularFireModule)(ɵngcc0.ɵɵinject(PLATFORM_ID));\n  },\n  providers: [FirebaseAppProvider]\n});\n/** @nocollapse */\n\nAngularFireModule.ctorParameters = () => [{\n  type: Object,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFireModule, [{\n    type: NgModule,\n    args: [{\n      providers: [FirebaseAppProvider]\n    }]\n  }], function () {\n    return [{\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy };","map":{"version":3,"sources":["ng:/@angular/fire/angularfire2.ts","ng:/@angular/fire/firebase.app.module.ts"],"names":["firebase.apps","firebase.initializeApp","firebase.registerVersion","NG_VERSION"],"mappings":"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","sourcesContent":["import { NgZone } from '@angular/core';\nimport { Observable, Subscription, SchedulerLike, SchedulerAction, queueScheduler, Operator, Subscriber, TeardownLogic, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap } from 'rxjs/operators';\n\nfunction noop() { }\n\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nexport class ɵZoneScheduler implements SchedulerLike {\n  constructor(private zone: any, private delegate: any = queueScheduler) { }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work: (this: SchedulerAction<any>, state?: any) => void, delay?: number, state?: any): Subscription {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (this: SchedulerAction<any>, state: any) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    }\n\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state)\n  }\n}\n\nexport class ɵBlockUntilFirstOperator<T> implements Operator<T, T> {\n  private task: MacroTask | null = null;\n\n  constructor(private zone: any) { }\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n\n    return source.pipe(\n      tap(unscheduleTask, unscheduleTask, unscheduleTask)\n    ).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  private unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on    \n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n}\n\nexport class ɵAngularFireSchedulers {\n  public readonly outsideAngular: ɵZoneScheduler;\n  public readonly insideAngular: ɵZoneScheduler;\n\n  constructor(public ngZone: NgZone) {\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n}\n\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nexport function ɵkeepUnstableUntilFirstFactory(\n  schedulers: ɵAngularFireSchedulers,\n  platformId: Object\n) {\n  return function keepUnstableUntilFirst<T>(obs$: Observable<T>): Observable<T> {\n    obs$ = obs$.lift(\n      new ɵBlockUntilFirstOperator(schedulers.ngZone)\n    );\n\n    return obs$.pipe(\n      // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular),\n      // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular)\n      // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n      // share()\n    );\n  }\n}\n\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype PromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? K : never }[FunctionPropertyNames<T>];\ntype NonPromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? never : K }[FunctionPropertyNames<T>];\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\n\nexport type ɵPromiseProxy<T> = { [K in NonFunctionPropertyNames<T>]: Promise<T[K]> } &\n  { [K in NonPromiseReturningFunctionPropertyNames<T>]: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>> } &\n  { [K in PromiseReturningFunctionPropertyNames<T>   ]: (...args: Parameters<T[K]>) => ReturnType<T[K]> };\n\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nexport const ɵlazySDKProxy = (klass: any, observable: Observable<any>, zone: NgZone) => {\n  return new Proxy(klass, {\n    get: (_, name:string) => zone.runOutsideAngular(() => {\n      if (klass[name]) { return klass[name] }\n      if (noopFunctions.includes(name)) { return () => {} }\n      let promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n        // TODO move to proper type guards\n        if (typeof ret == 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then((res:any) => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => undefined, {\n          get: (_, name) => promise[name],\n          // TODO handle callbacks as transparently as I can \n          apply: (self, _, args) => promise.then(it => it && it(...args))\n        }\n      )\n    })\n  })\n};","import { InjectionToken, NgModule, Optional, NgZone, VERSION as NG_VERSION, Version, PLATFORM_ID, Inject } from '@angular/core';\nimport { app, auth, database, messaging, storage, firestore, functions, analytics, performance, remoteConfig } from 'firebase/app';\nimport * as firebase from 'firebase/app';\n\n// INVESTIGATE Public types don't expose FirebaseOptions or FirebaseAppConfig, is this the case anylonger?\nexport interface FirebaseOptions {[key:string]: any};\nexport interface FirebaseAppConfig {[key:string]: any};\n\nexport const FIREBASE_OPTIONS = new InjectionToken<FirebaseOptions>('angularfire2.app.options');\nexport const FIREBASE_APP_NAME = new InjectionToken<string|FirebaseAppConfig|undefined>('angularfire2.app.nameOrConfig');\n\n// Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\nexport class FirebaseApp implements Partial<app.App> {\n    name: string;\n    options: {};\n    analytics: () => analytics.Analytics;\n    auth: () => auth.Auth;\n    database: (databaseURL?: string) => database.Database;\n    messaging: () => messaging.Messaging;\n    performance: () => performance.Performance;\n    storage: (storageBucket?: string) => storage.Storage;\n    delete: () => Promise<void>;\n    firestore: () => firestore.Firestore;\n    functions: (region?: string) => functions.Functions;\n    remoteConfig: () => remoteConfig.RemoteConfig;\n}\n\nexport const VERSION = new Version('ANGULARFIRE2_VERSION');\n\nexport function ɵfirebaseAppFactory(options: FirebaseOptions, zone: NgZone, nameOrConfig?: string|FirebaseAppConfig|null) {\n    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n    config.name = config.name || name;\n    // Added any due to some inconsistency between @firebase/app and firebase types\n    const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0] as any;\n    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n    return (existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config as any))) as FirebaseApp;\n}\n\nconst FirebaseAppProvider = {\n    provide: FirebaseApp,\n    useFactory: ɵfirebaseAppFactory,\n    deps: [\n        FIREBASE_OPTIONS,\n        NgZone,\n        [new Optional(), FIREBASE_APP_NAME]\n    ]\n};\n \n@NgModule({\n    providers: [ FirebaseAppProvider ],\n})\nexport class AngularFireModule {\n    static initializeApp(options: FirebaseOptions, nameOrConfig?: string | FirebaseAppConfig) {\n        return {\n            ngModule: AngularFireModule,\n            providers: [\n                { provide: FIREBASE_OPTIONS, useValue: options },\n                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }\n            ]\n        }\n    }\n    constructor(@Inject(PLATFORM_ID) platformId:Object ) {\n        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n        firebase.registerVersion('angular', NG_VERSION.full);\n    }\n}"]},"metadata":{},"sourceType":"module"}